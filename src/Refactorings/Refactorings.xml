<?xml version="1.0" encoding="utf-8"?>
<Refactorings>
  <Refactoring Id="RR0002" Identifier="AddBraces" Title="Add braces">
    <Syntaxes>
      <Syntax>do statement</Syntax>
      <Syntax>else clause</Syntax>
      <Syntax>fixed statement</Syntax>
      <Syntax>for statement</Syntax>
      <Syntax>foreach statement</Syntax>
      <Syntax>if statement</Syntax>
      <Syntax>lock statement</Syntax>
      <Syntax>using statement</Syntax>
      <Syntax>while statement</Syntax>
    </Syntaxes>
    <Span>embedded statement</Span>
  </Refactoring>
  <Refactoring Id="RR0003" Identifier="AddBracesToIfElse" Title="Add braces to if-else">
    <Syntaxes>
      <Syntax>if-else chain</Syntax>
    </Syntaxes>
    <Span>embedded statement</Span>
  </Refactoring>
  <Refactoring Id="RR0004" Identifier="AddBracesToSwitchSection" Title="Add braces to switch section">
    <Syntaxes>
      <Syntax>switch section</Syntax>
    </Syntaxes>
    <Span>case or default keyword</Span>
  </Refactoring>
  <Refactoring Id="RR0005" Identifier="AddBracesToSwitchSections" Title="Add braces to switch sections">
    <Syntaxes>
      <Syntax>switch statement</Syntax>
    </Syntaxes>
    <Span>case or default keyword</Span>
  </Refactoring>
  <Refactoring Id="RR0006" Identifier="AddCastExpression" Title="Add cast expression">
    <Syntaxes>
      <Syntax>argument</Syntax>
      <Syntax>assignment expression</Syntax>
      <Syntax>return statement</Syntax>
      <Syntax>variable declaration</Syntax>
    </Syntaxes>
    <Images>
      <Image>AddCastExpressionToArgument</Image>
      <Image>AddCastExpressionToAssignmentExpression</Image>
      <Image>AddCastExpressionToReturnStatement</Image>
      <Image>AddCastExpressionToVariableDeclaration</Image>
    </Images>
  </Refactoring>
  <Refactoring Id="RR0007" Identifier="AddDefaultValueToParameter" Title="Add default value to parameter">
    <Syntaxes>
      <Syntax>parameter without default value</Syntax>
    </Syntaxes>
    <Span>identifier</Span>
  </Refactoring>
  <Refactoring Id="RR0008" Identifier="AddDefaultValueToReturnStatement" Title="Add default value to return statement" IsObsolete="true">
    <Syntaxes>
      <Syntax>return statement without expression</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0009" Identifier="AddExceptionToDocumentationComment" Title="Add exception to documentation comment">
    <Syntaxes>
      <Syntax>throw statement</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0010" Identifier="AddIdentifierToVariableDeclaration" Title="Add identifier to variable declaration" IsEnabledByDefault="false">
    <Syntaxes>
      <Syntax>variable declaration</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0011" Identifier="AddParameterNameToArgument" Title="Add parameter name to argument">
    <Syntaxes>
      <Syntax>argument list</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0012" Identifier="AddIdentifierToParameter" Title="Add identifier to parameter" IsEnabledByDefault="false">
    <Syntaxes>
      <Syntax>parameter</Syntax>
    </Syntaxes>
    <Span>missing identifier</Span>
  </Refactoring>
  <Refactoring Id="RR0013" Identifier="AddUsingDirective" Title="Add using directive">
    <Syntaxes>
      <Syntax>qualified name</Syntax>
    </Syntaxes>
    <Span>selected namespace</Span>
  </Refactoring>
  <Refactoring Id="RR0014" Identifier="AddUsingStaticDirective" Title="Add using static directive">
    <Syntaxes>
      <Syntax>member access expression (public or internal static class)</Syntax>
    </Syntaxes>
    <Span>selected class name</Span>
  </Refactoring>
  <Refactoring Id="RR0015" Identifier="CallConfigureAwait" Title="Call 'ConfigureAwait(false)'" IsObsolete="true">
    <Syntaxes>
      <Syntax>awaitable method invocation</Syntax>
    </Syntaxes>
    <Span>method name</Span>
  </Refactoring>
  <Refactoring Id="RR0016" Identifier="CallExtensionMethodAsInstanceMethod" Title="Call extension method as instance method">
    <Syntaxes>
      <Syntax>method invocation</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0017" Identifier="CallToMethod" Title="Call 'To...' method (ToString, ToArray, ToList)">
    <Syntaxes>
      <Syntax>argument</Syntax>
      <Syntax>assignment expression</Syntax>
      <Syntax>return statement</Syntax>
      <Syntax>variable declaration</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0018" Identifier="ChangeExplicitTypeToVar" Title="Change explicit type to 'var'">
    <Syntaxes>
      <Syntax>variable declaration</Syntax>
      <Syntax>foreach statement</Syntax>
    </Syntaxes>
    <Span>type</Span>
  </Refactoring>
  <Refactoring Id="RR0019" Identifier="ChangeMemberTypeAccordingToReturnExpression" Title="Change method/property/indexer type according to return expression" IsObsolete="true">
    <Syntaxes>
      <Syntax>return statement in method/property/indexer</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0020" Identifier="ChangeMemberTypeAccordingToYieldReturnExpression" Title="Change method/property/indexer type according to yield return expression" IsObsolete="true">
    <Syntaxes>
      <Syntax>yield return statement in method/property/indexer</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0021" Identifier="ChangeMethodReturnTypeToVoid" Title="Change method return type to 'void'">
    <Syntaxes>
      <Syntax>method</Syntax>
      <Syntax>local function</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0022" Identifier="ChangeTypeAccordingToExpression" Title="Change type according to expression">
    <Syntaxes>
      <Syntax>variable declaration</Syntax>
      <Syntax>foreach statement</Syntax>
    </Syntaxes>
    <Span>type</Span>
    <Samples>
      <Sample>
        <Before><![CDATA[IEnumerable<object> items = new List<object>();]]></Before>
        <After><![CDATA[List<object> items = new List<object>();]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0023" Identifier="ChangeVarToExplicitType" Title="Change 'var' to explicit type">
    <Syntaxes>
      <Syntax>variable declaration</Syntax>
      <Syntax>foreach statetement</Syntax>
    </Syntaxes>
    <Span>type</Span>
  </Refactoring>
  <Refactoring Id="RR0024" Identifier="CheckExpressionForNull" Title="Check expression for null">
    <Syntaxes>
      <Syntax>local declaration (identifier)</Syntax>
      <Syntax>assignment expression (left)</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0025" Identifier="CheckParameterForNull" Title="Check parameter for null">
    <Syntaxes>
      <Syntax>parameter</Syntax>
    </Syntaxes>
    <Span>parameter identifier</Span>
  </Refactoring>
  <Refactoring Id="RR0026" Identifier="CollapseToInitializer" Title="Collapse to initalizer">
    <Syntaxes>
      <Syntax>object creation followed with assignment(s)</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0027" Identifier="CommentOutMember" Title="Comment out member">
    <Syntaxes>
      <Syntax>method</Syntax>
      <Syntax>constructor</Syntax>
      <Syntax>property</Syntax>
      <Syntax>indexer</Syntax>
      <Syntax>operator</Syntax>
      <Syntax>event</Syntax>
      <Syntax>namespace</Syntax>
      <Syntax>class</Syntax>
      <Syntax>struct</Syntax>
      <Syntax>interface</Syntax>
    </Syntaxes>
    <Span>opening or closing brace</Span>
  </Refactoring>
  <Refactoring Id="RR0028" Identifier="CommentOutStatement" Title="Comment out statement">
    <Syntaxes>
      <Syntax>do statement</Syntax>
      <Syntax>fixed statement</Syntax>
      <Syntax>for statement</Syntax>
      <Syntax>foreach statement</Syntax>
      <Syntax>checked statement</Syntax>
      <Syntax>if statement</Syntax>
      <Syntax>lock statement</Syntax>
      <Syntax>switch statement</Syntax>
      <Syntax>try statement</Syntax>
      <Syntax>unchecked statement</Syntax>
      <Syntax>unsafe statement</Syntax>
      <Syntax>using statement</Syntax>
      <Syntax>while statement</Syntax>
    </Syntaxes>
    <Span>opening or closing brace</Span>
  </Refactoring>
  <Refactoring Id="RR0029" Identifier="CopyDocumentationCommentFromBaseMember" Title="Copy documentation comment from base member">
    <Syntaxes>
      <Syntax>constructor</Syntax>
      <Syntax>method</Syntax>
      <Syntax>property</Syntax>
      <Syntax>indexer</Syntax>
      <Syntax>event</Syntax>
    </Syntaxes>
    <Images>
      <Image>CopyDocumentationCommentFromBaseMember</Image>
      <Image>CopyDocumentationCommentFromImplementedMember</Image>
    </Images>
  </Refactoring>
  <Refactoring Id="RR0030" Identifier="DuplicateArgument" Title="Duplicate argument">
    <Syntaxes>
      <Syntax>missing argument</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0031" Identifier="DuplicateMember" Title="Duplicate member">
    <Syntaxes>
      <Syntax>method</Syntax>
      <Syntax>constructor</Syntax>
      <Syntax>property</Syntax>
      <Syntax>indexer</Syntax>
      <Syntax>operator</Syntax>
      <Syntax>event</Syntax>
      <Syntax>namespace</Syntax>
      <Syntax>class</Syntax>
      <Syntax>struct</Syntax>
      <Syntax>interface</Syntax>
    </Syntaxes>
    <Span>opening or closing brace</Span>
  </Refactoring>
  <Refactoring Id="RR0032" Identifier="DuplicateParameter" Title="Duplicate parameter">
    <Syntaxes>
      <Syntax>missing parameter</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0033" Identifier="DuplicateStatement" Title="Duplicate statement">
    <Syntaxes>
      <Syntax>do statement</Syntax>
      <Syntax>fixed statement</Syntax>
      <Syntax>for statement</Syntax>
      <Syntax>foreach statement</Syntax>
      <Syntax>checked statement</Syntax>
      <Syntax>if statement</Syntax>
      <Syntax>lock statement</Syntax>
      <Syntax>switch statement</Syntax>
      <Syntax>try statement</Syntax>
      <Syntax>unchecked statement</Syntax>
      <Syntax>unsafe statement</Syntax>
      <Syntax>using statement</Syntax>
      <Syntax>while statement</Syntax>
    </Syntaxes>
    <Span>opening or closing brace</Span>
  </Refactoring>
  <Refactoring Id="RR0034" Identifier="ExpandCompoundAssignmentOperator" Title="Expand compound assignment operator">
    <Syntaxes>
      <Syntax>compound assignment expression</Syntax>
    </Syntaxes>
    <Span>operator</Span>
  </Refactoring>
  <Refactoring Id="RR0035" Identifier="ExpandCoalesceExpression" Title="Expand coalesce expression">
    <Syntaxes>
      <Syntax>coalesce expression</Syntax>
    </Syntaxes>
    <Span>?? operator</Span>
  </Refactoring>
  <Refactoring Id="RR0036" Identifier="ExpandEvent" Title="Expand event">
    <Syntaxes>
      <Syntax>event field declaration</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0037" Identifier="ConvertExpressionBodyToBlockBody" Title="Convert expression-body to block body">
    <Syntaxes>
      <Syntax>expression body</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0038" Identifier="ExpandInitializer" Title="Expand initializer">
    <Syntaxes>
      <Syntax>initializer</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0039" Identifier="ConvertLambdaExpressionBodyToBlockBody" Title="Convert lambda expression body to block body">
    <Syntaxes>
      <Syntax>lambda expression's expression body</Syntax>
    </Syntaxes>
    <Span>body</Span>
  </Refactoring>
  <Refactoring Id="RR0040" Identifier="ExpandProperty" Title="Expand property">
    <Syntaxes>
      <Syntax>auto-property</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0041" Identifier="ExpandPropertyAndAddBackingField" Title="Expand property and add backing field">
    <Syntaxes>
      <Syntax>auto-property</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0043" Identifier="ExtractExpressionFromCondition" Title="Extract expression from condition">
    <Syntaxes>
      <Syntax>if statement</Syntax>
      <Syntax>while statement</Syntax>
    </Syntaxes>
    <Span>condition</Span>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x && y) // Select 'y'
{
}]]></Before>
        <After><![CDATA[if(x)
{
    if (y)
    {
    }
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[if (x || y) // Select 'y'
{
}]]></Before>
        <After><![CDATA[if(x)
{
}

if (y)
{
}]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0044" Identifier="ExtractGenericType" Title="Extract generic type">
    <Syntaxes>
      <Syntax>generic name with single type argument</Syntax>
    </Syntaxes>
    <Span>type argument</Span>
  </Refactoring>
  <Refactoring Id="RR0045" Identifier="ExtractStatement" Title="Extract statement(s)">
    <Syntaxes>
      <Syntax>else clause</Syntax>
      <Syntax>fixed statement</Syntax>
      <Syntax>for statement</Syntax>
      <Syntax>foreach statement</Syntax>
      <Syntax>checked statement</Syntax>
      <Syntax>if statement</Syntax>
      <Syntax>lock statement</Syntax>
      <Syntax>try statement</Syntax>
      <Syntax>unsafe statement</Syntax>
      <Syntax>using statement</Syntax>
      <Syntax>while statement</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0046" Identifier="ExtractTypeDeclarationToNewFile" Title="Extract type declaration to a new file">
    <Syntaxes>
      <Syntax>class declaration</Syntax>
      <Syntax>struct declaration</Syntax>
      <Syntax>interface declaration</Syntax>
      <Syntax>enum declaration</Syntax>
      <Syntax>delegate declaration</Syntax>
    </Syntaxes>
    <Span>identifier</Span>
  </Refactoring>
  <Refactoring Id="RR0047" Identifier="FormatAccessorBraces" Title="Format accessor braces" IsObsolete="true">
    <Syntaxes>
      <Syntax>get accessor</Syntax>
      <Syntax>set accessor</Syntax>
      <Syntax>add accessor</Syntax>
      <Syntax>remove accessor</Syntax>
    </Syntaxes>
    <Span>block</Span>
    <Images>
      <Image>FormatAccessorBracesOnMultipleLines</Image>
      <Image>FormatAccessorBracesOnSingleLine</Image>
    </Images>
  </Refactoring>
  <Refactoring Id="RR0048" Identifier="WrapArguments" Title="Wrap arguments">
    <Syntaxes>
      <Syntax>argument list</Syntax>
    </Syntaxes>
    <Samples>
      <Sample>
        <Before><![CDATA[M(x, y, z);]]></Before>
        <After>
          <![CDATA[M(
    x,
    y,
    z);]]></After>
      </Sample>
      <Sample>
        <Before>
          <![CDATA[void M(
    x,
    y,
    z);]]>
        </Before>
        <After>
          <![CDATA[void M(x, y, z);]]>
        </After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0049" Identifier="WrapBinaryExpression" Title="Wrap binary expression">
    <Syntaxes>
      <Syntax>logical and/or expression</Syntax>
      <Syntax>bitwise and/or expression</Syntax>
    </Syntaxes>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x && y && z)
{
}]]></Before>
        <After><![CDATA[if (x
    && y
    && z)
{
}]]></After>
      </Sample>
      <Sample>
        <Before>
          <![CDATA[if (x
    && y
    && z)
{
}]]>
        </Before>
        <After>
          <![CDATA[if (x && y && z)
{
}]]>
        </After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0050" Identifier="WrapConditionalExpression" Title="Wrap conditional expression">
    <Syntaxes>
      <Syntax>conditional expression</Syntax>
    </Syntaxes>
    <Samples>
      <Sample>
        <Before><![CDATA[x ? y : z]]></Before>
        <After><![CDATA[x
    ? y
    : z]]></After>
      </Sample>
    </Samples>
    <Samples>
      <Sample>
        <Before><![CDATA[x
    ? y
    : z]]></Before>
        <After><![CDATA[x ? y : z]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0051" Identifier="WrapCallChain" Title="Wrap call chain">
    <Syntaxes>
      <Syntax>call chain</Syntax>
    </Syntaxes>
    <Samples>
      <Sample>
        <Before><![CDATA[x.M().N().O()]]></Before>
        <After><![CDATA[x
    .M()
    .N()
    .O()]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[x
    .M()
    .N()
    .O()]]></Before>
        <After><![CDATA[x.M().N().O()]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0052" Identifier="WrapInitializerExpressions" Title="Wrap initializer expressions">
    <Syntaxes>
      <Syntax>initializer</Syntax>
    </Syntaxes>
    <Samples>
      <Sample>
        <Before><![CDATA[var x = new string[] { "a", "b", "c" }]]></Before>
        <After><![CDATA[var x = new string[]
{
    "a",
    "b",
    "c"
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[var x = new string[]
{
    "a",
    "b",
    "c"
}]]></Before>
        <After><![CDATA[var x = new string[] { "a", "b", "c" }]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0053" Identifier="WrapParameters" Title="Wrap parameters">
    <Syntaxes>
      <Syntax>parameter list</Syntax>
    </Syntaxes>
    <Samples>
      <Sample>
        <Before><![CDATA[void M(object x, object y, object z)
{
}]]></Before>
        <After>
          <![CDATA[void M(
    object x,
    object y,
    object z)
{
}]]></After>
      </Sample>
      <Sample>
        <Before>
          <![CDATA[void M(
    object x,
    object y,
    object z)
{
}]]>
        </Before>
        <After>
          <![CDATA[void M(object x, object y, object z)
{
}]]>
        </After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0054" Identifier="GenerateBaseConstructors" Title="Generate base constructors">
    <Syntaxes>
      <Syntax>class declaration</Syntax>
    </Syntaxes>
    <Span>identifier</Span>
  </Refactoring>
  <Refactoring Id="RR0055" Identifier="GenerateCombinedEnumMember" Title="Generate combined enum member">
    <Syntaxes>
      <Syntax>enum declaration (with FlagsAttribute)</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0056" Identifier="GenerateEnumMember" Title="Generate enum member">
    <Syntaxes>
      <Syntax>enum declaration (with FlagsAttribute)</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0057" Identifier="GenerateEnumValues" Title="Generate enum values">
    <Syntaxes>
      <Syntax>enum declaration (with FlagsAttribute)</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0058" Identifier="GenerateEventInvokingMethod" Title="Generate event invoking method">
    <Syntaxes>
      <Syntax>event</Syntax>
    </Syntaxes>
    <Span>identifier</Span>
  </Refactoring>
  <Refactoring Id="RR0059" Identifier="AddMissingCases" Title="Add missing cases to switch statement">
    <Syntaxes>
      <Syntax>switch statement</Syntax>
    </Syntaxes>
    <Samples>
      <Sample>
        <Before><![CDATA[switch (dayOfWeek)
{
    case DayOfWeek.Sunday:
        break;
    case DayOfWeek.Monday:
        break;
    case DayOfWeek.Tuesday:
        break;
    case DayOfWeek.Wednesday:
        break;
    case DayOfWeek.Thursday:
        break;
}
]]></Before>
        <After><![CDATA[switch (dayOfWeek)
{
    case DayOfWeek.Sunday:
        break;
    case DayOfWeek.Monday:
        break;
    case DayOfWeek.Tuesday:
        break;
    case DayOfWeek.Wednesday:
        break;
    case DayOfWeek.Thursday:
        break;
    case DayOfWeek.Friday:
        break;
    case DayOfWeek.Saturday:
        break;
}]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0060" Identifier="InitializeLocalWithDefaultValue" Title="Initialize local with default value">
    <Syntaxes>
      <Syntax>local declaration without initializer</Syntax>
    </Syntaxes>
    <Span>identifier</Span>
  </Refactoring>
  <Refactoring Id="RR0061" Identifier="InlineAliasExpression" Title="Inline alias expression">
    <Syntaxes>
      <Syntax>using alias directive</Syntax>
    </Syntaxes>
    <Span>identifier</Span>
  </Refactoring>
  <Refactoring Id="RR0062" Identifier="InlineMethod" Title="Inline method">
    <Syntaxes>
      <Syntax>method invocation</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0063" Identifier="InsertStringInterpolation" Title="Insert string interpolation">
    <Syntaxes>
      <Syntax>string literal</Syntax>
      <Syntax>interpolated string</Syntax>
    </Syntaxes>
    <Images>
      <Image>InsertInterpolationIntoStringLiteral</Image>
      <Image>InsertInterpolationIntoInterpolatedString</Image>
    </Images>
  </Refactoring>
  <Refactoring Id="RR0064" Identifier="IntroduceAndInitializeField" Title="Introduce and initialize field">
    <Syntaxes>
      <Syntax>constructor parameter</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0065" Identifier="IntroduceAndInitializeProperty" Title="Introduce and initialize property">
    <Syntaxes>
      <Syntax>constructor parameter</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0066" Identifier="IntroduceConstructor" Title="Introduce constructor" IsEnabledByDefault="false">
    <Syntaxes>
      <Syntax>field</Syntax>
      <Syntax>property</Syntax>
    </Syntaxes>
    <Span></Span>
  </Refactoring>
  <Refactoring Id="RR0067" Identifier="IntroduceFieldToLockOn" Title="Introduce field to lock on">
    <Syntaxes>
      <Syntax>lock statement</Syntax>
    </Syntaxes>
    <Span>missing expression</Span>
  </Refactoring>
  <Refactoring Id="RR0068" Identifier="IntroduceLocalVariable" Title="Introduce local variable">
    <Syntaxes>
      <Syntax>expression statement</Syntax>
      <Syntax>expression in using statement</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0069" Identifier="MakeMemberAbstract" Title="Make member abstract">
    <Syntaxes>
      <Syntax>non-abstract indexer/method/property in abstract class</Syntax>
    </Syntaxes>
    <Span>indexer/method/property header</Span>
  </Refactoring>
  <Refactoring Id="RR0070" Identifier="MakeMemberVirtual" Title="Make member virtual">
    <Syntaxes>
      <Syntax>method declaration</Syntax>
      <Syntax>indexer declaration</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0073" Identifier="MergeAssignmentExpressionWithReturnStatement" Title="Merge assignment expression with return statement">
    <Syntaxes>
      <Syntax>assignment expression followed with return statement</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0074" Identifier="MergeAttributes" Title="Merge attributes">
    <Syntaxes>
      <Syntax>selected attribute lists</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0075" Identifier="MergeIfStatements" Title="Merge 'if' statements">
    <Syntaxes>
      <Syntax>selected 'if' statements</Syntax>
    </Syntaxes>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x)
{
    return false;
}

if (y)
{
    return false;
}

return true;]]></Before>
        <After><![CDATA[if (x || y)
{
    return false;
}

return true;]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0076" Identifier="MergeInterpolationIntoInterpolatedString" Title="Merge interpolation into interpolated string" IsObsolete="true">
    <Syntaxes>
      <Syntax>interpolation</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0077" Identifier="MergeLocalDeclarations" Title="Merge local declarations">
    <Syntaxes>
      <Syntax>local declarations with same type</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0078" Identifier="JoinStringExpressions" Title="Join string expressions">
    <Syntaxes>
      <Syntax>concatenated string expressions</Syntax>
    </Syntaxes>
    <Images>
      <Image>JoinStringExpressions</Image>
      <Image>JoinStringLiterals</Image>
      <Image>JoinStringLiteralsIntoMultilineStringLiteral</Image>
    </Images>
  </Refactoring>
  <Refactoring Id="RR0079" Identifier="InvertBinaryExpression" Title="Invert binary expression">
    <Syntaxes>
      <Syntax>logical and/or expression</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0080" Identifier="InvertBooleanLiteral" Title="Invert boolean literal">
    <Syntaxes>
      <Syntax>boolean literal</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0081" Identifier="InvertIsExpression" Title="Invert is expression">
    <Syntaxes>
      <Syntax>is expression</Syntax>
    </Syntaxes>
    <Span>operator</Span>
  </Refactoring>
  <Refactoring Id="RR0082" Identifier="InvertOperator" Title="Invert operator">
    <Syntaxes>
      <Syntax>!=</Syntax>
      <Syntax>&amp;&amp;</Syntax>
      <Syntax>||</Syntax>
      <Syntax>&lt;</Syntax>
      <Syntax>&lt;=</Syntax>
      <Syntax>==</Syntax>
      <Syntax>&gt;</Syntax>
      <Syntax>&gt;=</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0083" Identifier="NotifyWhenPropertyChange" Title="Notify when property change">
    <Syntaxes>
      <Syntax>property in class/struct that implements System.ComponentModel.INotifyPropertyChanged</Syntax>
    </Syntaxes>
    <Span>setter</Span>
  </Refactoring>
  <Refactoring Id="RR0084" Identifier="ParenthesizeExpression" Title="Parenthesize expression">
    <Syntaxes>
      <Syntax>selected expression</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0085" Identifier="PromoteLocalToParameter" Title="Promote local to parameter">
    <Syntaxes>
      <Syntax>local declaration in method</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0086" Identifier="RemoveAllComments" Title="Remove all comments">
    <Syntaxes>
      <Syntax>singleline/multiline comment</Syntax>
      <Syntax>singleline/multiline documentation documentation comment</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0087" Identifier="RemoveAllCommentsExceptDocumentationComments" Title="Remove all comments (except documentation comments)">
    <Syntaxes>
      <Syntax>singleline/multiline comment</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0088" Identifier="RemoveAllDocumentationComments" Title="Remove all documentation comments" IsEnabledByDefault="false">
    <Syntaxes>
      <Syntax>singleline/multiline documentation comment</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0089" Identifier="RemoveAllMemberDeclarations" Title="Remove all member declarations">
    <Syntaxes>
      <Syntax>namespace</Syntax>
      <Syntax>class</Syntax>
      <Syntax>struct</Syntax>
      <Syntax>interface</Syntax>
    </Syntaxes>
    <Span>opening or closing brace</Span>
  </Refactoring>
  <Refactoring Id="RR0090" Identifier="RemoveAllPreprocessorDirectives" Title="Remove all preprocessor directives">
    <Syntaxes>
      <Syntax>preprocessor directive</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0091" Identifier="RemoveAllRegionDirectives" Title="Remove all region directives">
    <Syntaxes>
      <Syntax>region directive</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0092" Identifier="RemoveAllStatements" Title="Remove all statements">
    <Syntaxes>
      <Syntax>method</Syntax>
      <Syntax>constructor</Syntax>
      <Syntax>operator</Syntax>
    </Syntaxes>
    <Span>opening or closing brace</Span>
  </Refactoring>
  <Refactoring Id="RR0093" Identifier="RemoveAllSwitchSections" Title="Remove all switch sections">
    <Syntaxes>
      <Syntax>switch statement</Syntax>
    </Syntaxes>
    <Span>opening or closing brace</Span>
  </Refactoring>
  <Refactoring Id="RR0094" Identifier="RemoveBraces" Title="Remove braces">
    <Syntaxes>
      <Syntax>do statement</Syntax>
      <Syntax>else clause</Syntax>
      <Syntax>fixed statement</Syntax>
      <Syntax>for statement</Syntax>
      <Syntax>foreach statement</Syntax>
      <Syntax>if statement</Syntax>
      <Syntax>lock statement</Syntax>
      <Syntax>using statement</Syntax>
      <Syntax>while statement</Syntax>
    </Syntaxes>
    <Span>block with a single statement</Span>
  </Refactoring>
  <Refactoring Id="RR0095" Identifier="RemoveBracesFromIfElse" Title="Remove braces from if-else">
    <Syntaxes>
      <Syntax>if-else chain</Syntax>
    </Syntaxes>
    <Span>embedded statement</Span>
  </Refactoring>
  <Refactoring Id="RR0096" Identifier="RemoveBracesFromSwitchSection" Title="Remove braces from switch section">
    <Syntaxes>
      <Syntax>switch section</Syntax>
    </Syntaxes>
    <Span>case or default keyword</Span>
  </Refactoring>
  <Refactoring Id="RR0097" Identifier="RemoveBracesFromSwitchSections" Title="Remove braces from switch sections">
    <Syntaxes>
      <Syntax>switch statement</Syntax>
    </Syntaxes>
    <Span>case or default keyword</Span>
  </Refactoring>
  <Refactoring Id="RR0098" Identifier="RemoveComment" Title="Remove comment">
    <Syntaxes>
      <Syntax>singleline/multiline comment</Syntax>
      <Syntax>singleline/multiline xml documentation comment</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0099" Identifier="RemoveConditionFromLastElse" Title="Remove condition from last else clause">
    <Syntaxes>
      <Syntax>else clause</Syntax>
    </Syntaxes>
    <Span>else keyword</Span>
  </Refactoring>
  <Refactoring Id="RR0100" Identifier="RemoveDirectiveAndRelatedDirectives" Title="Remove directive and related directives">
    <Syntaxes>
      <Syntax>preprocessor directive</Syntax>
      <Syntax>region directive</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0101" Identifier="RemoveEmptyLines" Title="Remove empty lines">
    <Syntaxes>
      <Syntax>selected lines</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0102" Identifier="RemoveInterpolation" Title="Remove interpolation">
    <Syntaxes>
      <Syntax>string interpolation</Syntax>
    </Syntaxes>
    <Span>opening or closing brace</Span>
  </Refactoring>
  <Refactoring Id="RR0103" Identifier="RemoveMember" Title="Remove member">
    <Syntaxes>
      <Syntax>method</Syntax>
      <Syntax>constructor</Syntax>
      <Syntax>property</Syntax>
      <Syntax>indexer</Syntax>
      <Syntax>operator</Syntax>
      <Syntax>event</Syntax>
      <Syntax>namespace</Syntax>
      <Syntax>class</Syntax>
      <Syntax>struct</Syntax>
      <Syntax>interface</Syntax>
    </Syntaxes>
    <Span>opening or closing brace</Span>
  </Refactoring>
  <Refactoring Id="RR0104" Identifier="RemoveMemberDeclarations" Title="Remove member declarations above/below">
    <Syntaxes>
      <Syntax>empty line between member declarations</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0105" Identifier="RemoveParameterNameFromArgument" Title="Remove parameter name from argument">
    <Syntaxes>
      <Syntax>selected argument(s)</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0106" Identifier="RemoveParentheses" Title="Remove parentheses">
    <Syntaxes>
      <Syntax>parenthesized expression</Syntax>
    </Syntaxes>
    <Span>opening or closing parenthesis</Span>
  </Refactoring>
  <Refactoring Id="RR0107" Identifier="RemovePropertyInitializer" Title="Remove property initializer">
    <Syntaxes>
      <Syntax>property initializer</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0108" Identifier="RemoveRegion" Title="Remove region">
    <Syntaxes>
      <Syntax>region directive</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0109" Identifier="RemoveStatement" Title="Remove statement">
    <Syntaxes>
      <Syntax>do statement</Syntax>
      <Syntax>fixed statement</Syntax>
      <Syntax>for statement</Syntax>
      <Syntax>foreach statement</Syntax>
      <Syntax>checked statement</Syntax>
      <Syntax>if statement</Syntax>
      <Syntax>lock statement</Syntax>
      <Syntax>switch statement</Syntax>
      <Syntax>try statement</Syntax>
      <Syntax>unchecked statement</Syntax>
      <Syntax>unsafe statement</Syntax>
      <Syntax>using statement</Syntax>
      <Syntax>while statement</Syntax>
    </Syntaxes>
    <Span>open/close brace</Span>
  </Refactoring>
  <Refactoring Id="RR0110" Identifier="RemoveStatementsFromSwitchSections" Title="Remove statements from switch sections">
    <Syntaxes>
      <Syntax>selected switch sections</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0111" Identifier="RenameBackingFieldAccordingToPropertyName" Title="Rename backing field according to property name">
    <Syntaxes>
      <Syntax>field identifier inside property declaration</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0112" Identifier="RenameIdentifierAccordingToTypeName" Title="Rename identifier according to type name">
    <Syntaxes>
      <Syntax>foreach statement</Syntax>
      <Syntax>local/field/constant declaration</Syntax>
    </Syntaxes>
    <Span>identifier</Span>
    <Images>
      <Image>RenameForEachIdentifierAccordingToTypeName</Image>
      <Image>RenameFieldIdentifierAccordingToTypeName</Image>
    </Images>
  </Refactoring>
  <Refactoring Id="RR0113" Identifier="RenameMethodAccordingToTypeName" Title="Rename method according to type name">
    <Syntaxes>
      <Syntax>method</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0114" Identifier="RenameParameterAccordingToTypeName" Title="Rename parameter according to its type name">
    <Syntaxes>
      <Syntax>parameter</Syntax>
    </Syntaxes>
    <Span>parameter identifier</Span>
  </Refactoring>
  <Refactoring Id="RR0115" Identifier="RenamePropertyAccordingToTypeName" Title="Rename property according to type name">
    <Syntaxes>
      <Syntax>property identifier</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0116" Identifier="InvertLinqMethodCall" Title="Invert LINQ method call">
    <Syntaxes>
      <Syntax>System.Linq.Enumerable.Any(Func&lt;T, bool&gt;) or System.Linq.Enumerable.All(Func&lt;T, bool&gt;)</Syntax>
    </Syntaxes>
    <Span>method name</Span>
    <Samples>
      <Sample>
        <Before><![CDATA[if (items.Any(predicate)
{
}]]></Before>
        <After><![CDATA[if (items.All(!predicate)
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[if (items.All(predicate)
{
}]]></Before>
        <After><![CDATA[if (items.Any(!predicate)
{
}]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0117" Identifier="ReplaceAsWithCast" Title="Replace as expression with cast expression">
    <Syntaxes>
      <Syntax>as expression</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0118" Identifier="ReplaceCastWithAs" Title="Replace cast expression with as expression">
    <Syntaxes>
      <Syntax>cast expression</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0119" Identifier="ReplaceConditionalExpressionWithExpression" Title="Replace conditional expression with expression">
    <Syntaxes>
      <Syntax>conditional expression</Syntax>
    </Syntaxes>
    <Span>selected true/false expression</Span>
  </Refactoring>
  <Refactoring Id="RR0120" Identifier="ConvertConditionalOperatorToIfElse" Title="Convert ?: to if-else">
    <Syntaxes>
      <Syntax>?: operator that is part of local declaration, assignment or (yield) return statement</Syntax>
    </Syntaxes>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = (x) ? "a" : "b";]]></Before>
        <After><![CDATA[string s;
if (x)
{
    s = "a";
}
else
{
    s = "b";
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[string s = (x) ? "a" : (y) ? "b" : "c";]]></Before>
        <After><![CDATA[string s;
if (x)
{
    s = "a";
}
else if (y)
{
    s = "b";
}
else
{
    s = "c";
}]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0121" Identifier="ReplaceConstantWithField" Title="Replace constant with field">
    <Syntaxes>
      <Syntax>constant declaration</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0123" Identifier="ConvertDoToWhile" Title="Convert 'do' to 'while'">
    <Syntaxes>
      <Syntax>do statement</Syntax>
    </Syntaxes>
    <Span>do keyword</Span>
    <Samples>
      <Sample>
        <Before><![CDATA[do
{
} while (condition);]]></Before>
        <After><![CDATA[while (condition)
{
}]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0124" Identifier="ReplaceEqualsExpressionWithStringEquals" Title="Replace equals expression with string.Equals">
    <Syntaxes>
      <Syntax>equals expression</Syntax>
      <Syntax>not equals expression</Syntax>
    </Syntaxes>
    <Span>operator</Span>
  </Refactoring>
  <Refactoring Id="RR0125" Identifier="ReplaceEqualsExpressionWithStringIsNullOrEmpty" Title="Replace equals expression with string.IsNullOrEmpty">
    <Syntaxes>
      <Syntax>equals expression</Syntax>
      <Syntax>not equals expression</Syntax>
    </Syntaxes>
    <Span>operator</Span>
  </Refactoring>
  <Refactoring Id="RR0126" Identifier="ReplaceEqualsExpressionWithStringIsNullOrWhiteSpace" Title="Replace equals expression with string.IsNullOrWhiteSpace">
    <Syntaxes>
      <Syntax>equals expression</Syntax>
      <Syntax>not equals expression</Syntax>
    </Syntaxes>
    <Span>operator</Span>
  </Refactoring>
  <Refactoring Id="RR0127" Identifier="InlineConstantValue" Title="Inline constant value">
    <Syntaxes>
      <Syntax>expression that has constant value</Syntax>
    </Syntaxes>
    <Samples>
      <Sample>
        <Before><![CDATA[public const string Value = "x";

void Foo()
{
    string x = Value;
}]]></Before>
        <After><![CDATA[public const string Value = "x";

void Foo()
{
    string x = "x";
}]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0128" Identifier="UseConstantInsteadOfField" Title="Use constant instead of field">
    <Syntaxes>
      <Syntax>read-only field</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0129" Identifier="ConvertForEachToFor" Title="Convert 'foreach' to 'for'">
    <Syntaxes>
      <Syntax>foreach statement</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0130" Identifier="ConvertForToForEach" Title="Convert 'for' to 'foreach'">
    <Syntaxes>
      <Syntax>for statement</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0131" Identifier="ConvertForToWhile" Title="Convert 'for' to 'while'">
    <Syntaxes>
      <Syntax>for statement</Syntax>
    </Syntaxes>
    <Span>for keyword or selected for statement</Span>
  </Refactoring>
  <Refactoring Id="RR0132" Identifier="ConvertHexadecimalLiteralToDecimalLiteral" Title="Convert hexadecimal literal to decimal literal">
    <Syntaxes>
      <Syntax>hexadecimal literal</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0133" Identifier="ConvertIfToSwitch" Title="Convert 'if' to 'switch'">
    <Syntaxes>
      <Syntax>if statement</Syntax>
    </Syntaxes>
    <Span>top if keyword or selected if statement</Span>
    <Samples>
      <Sample>
        <Before><![CDATA[var ch = stringReader.Read();

if (ch == 10 || ch == 13)
{
    return;
}
else
{
    stringBuilder.Append(ch);
}]]></Before>
        <After><![CDATA[var ch = stringReader.Read();

switch (ch)
{
    case 10:
    case 13:
        {
            return;
        }

    default:
        {
            stringBuilder.Append(ch);
            break;
        }
}]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0134" Identifier="InvertPrefixOrPostfixUnaryOperator" Title="Invert prefix/postfix unary operator">
    <Syntaxes>
      <Syntax>prefix/postfix unary expression</Syntax>
    </Syntaxes>
    <Span>operator token</Span>
    <Samples>
      <Sample>
        <Before><![CDATA[int i = 0;

i++;]]></Before>
        <After><![CDATA[int i = 0;

i--;]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[int i = 0;

++i;]]></Before>
        <After><![CDATA[int i = 0;

--i;]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0135" Identifier="ReplaceInterpolatedStringWithInterpolationExpression" Title="Replace interpolated string with interpolation expression">
    <Syntaxes>
      <Syntax>interpolated string with single interpolation and no text</Syntax>
    </Syntaxes>
    <Span>interpolation</Span>
  </Refactoring>
  <Refactoring Id="RR0136" Identifier="ConvertInterpolatedStringToStringLiteral" Title="Convert interpolated string to string literal">
    <Syntaxes>
      <Syntax>Interpolated string without any interpolation</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0137" Identifier="ConvertMethodGroupToLambda" Title="Convert method group to lambda">
    <Syntaxes>
      <Syntax>method group</Syntax>
    </Syntaxes>
    <Samples>
      <Sample>
        <Before><![CDATA[Func<object, object, object> func = Foo;]]></Before>
        <After><![CDATA[Func<object, object, object> func = (f, g) => Foo(f, g)]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0138" Identifier="ReplaceMethodWithProperty" Title="Replace method with property" IsEnabledByDefault="false">
    <Syntaxes>
      <Syntax>method</Syntax>
    </Syntaxes>
    <Span>method header</Span>
  </Refactoring>
  <Refactoring Id="RR0139" Identifier="ConvertNullLiteralToDefaultExpression" Title="Convert null literal to default expression">
    <Syntaxes>
      <Syntax>argument</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0140" Identifier="ReplacePrefixOperatorWithPostfixOperator" Title="Replace prefix operator to postfix operator">
    <Syntaxes>
      <Syntax>prefix/postfix unary expression</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0141" Identifier="ReplacePropertyWithMethod" Title="Replace property with method">
    <Syntaxes>
      <Syntax>read-only property</Syntax>
    </Syntaxes>
    <Span>property header</Span>
  </Refactoring>
  <Refactoring Id="RR0142" Identifier="ConvertRegularStringLiteralToVerbatimStringLiteral" Title="Convert regular string literal to verbatim string literal">
    <Syntaxes>
      <Syntax>regular string literal</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0143" Identifier="ConvertReturnToIf" Title="Convert '(yield) return' to 'if'">
    <Syntaxes>
      <Syntax>return statement</Syntax>
      <Syntax>yield return statement</Syntax>
    </Syntaxes>
    <Span>selected statement, yield keyword or return keyword</Span>
    <Images>
      <Image>ReplaceReturnStatementWithIfElse</Image>
    </Images>
  </Refactoring>
  <Refactoring Id="RR0144" Identifier="CallIndexOfInsteadOfContains" Title="Call string.IndexOf instead of string.Contains">
    <Syntaxes>
      <Syntax>method invocation</Syntax>
    </Syntaxes>
    <Span>method name</Span>
    <Samples>
      <Sample>
        <Before><![CDATA[if (s.Contains("a"))
{
{]]></Before>
        <After><![CDATA[if (s.IndexOf("a", StringComparison.OrdinalIgnoreCase) != -1)
{
{]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0145" Identifier="ConvertStringFormatToInterpolatedString" Title="Convert 'string.Format' to interpolated string">
    <Syntaxes>
      <Syntax>string.Format method</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0147" Identifier="ConvertSwitchToIf" Title="Convert 'switch' to 'if'">
    <Syntaxes>
      <Syntax>switch statement</Syntax>
    </Syntaxes>
    <Span>switch keyword</Span>
  </Refactoring>
  <Refactoring Id="RR0148" Identifier="ConvertVerbatimStringLiteralToRegularStringLiteral" Title="Convert verbatim string literal to regular string literal">
    <Syntaxes>
      <Syntax>verbatim string literal</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0149" Identifier="ConvertVerbatimStringLiteralToRegularStringLiterals" Title="Convert verbatim string literal to regular string literals">
    <Syntaxes>
      <Syntax>multiline verbatim string literal</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0150" Identifier="ConvertWhileToDo" Title="Convert 'while' statement to 'do' statement">
    <Syntaxes>
      <Syntax>while statement</Syntax>
    </Syntaxes>
    <Span>while keyword</Span>
    <Samples>
      <Sample>
        <Before><![CDATA[while (condition)
{
}]]></Before>
        <After><![CDATA[if (condition)
{
  do
  {
  } while (condition);
}]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0151" Identifier="ConvertWhileToFor" Title="Convert 'while' statement to 'for' statement">
    <Syntaxes>
      <Syntax>while statement</Syntax>
    </Syntaxes>
    <Span>while keyword or selected statement(s)</Span>
  </Refactoring>
  <Refactoring Id="RR0152" Identifier="ReverseForStatement" Title="Reverse 'for' statement">
    <Syntaxes>
      <Syntax>for statement</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0153" Identifier="SimplifyIf" Title="Simplify if">
    <Syntaxes>
      <Syntax>if statement</Syntax>
    </Syntaxes>
    <Span>top if keyword or selected if statement</Span>
  </Refactoring>
  <Refactoring Id="RR0154" Identifier="ConvertLambdaExpressionBodyToExpressionBody" Title="Convert lambda expression body to expression-body">
    <Syntaxes>
      <Syntax>lambda expression with block body with single single-line statement</Syntax>
    </Syntaxes>
    <Span>body</Span>
  </Refactoring>
  <Refactoring Id="RR0155" Identifier="SortMemberDeclarations" Title="Sort member declarations">
    <Syntaxes>
      <Syntax>namespace declarations</Syntax>
      <Syntax>class declarations</Syntax>
      <Syntax>struct declarations</Syntax>
      <Syntax>interface declarations</Syntax>
      <Syntax>enum declarations</Syntax>
    </Syntaxes>
    <Span>selected member declarations</Span>
    <Images>
      <Image>SortMembersByKind</Image>
      <Image>SortMembersByName</Image>
      <Image>SortEnumMembersByName</Image>
      <Image>SortEnumMembersByValue</Image>
    </Images>
  </Refactoring>
  <Refactoring Id="RR0156" Identifier="SplitAttributes" Title="Split attributes">
    <Syntaxes>
      <Syntax>selected attribute list</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0157" Identifier="SplitSwitchLabels" Title="Split switch labels">
    <Syntaxes>
      <Syntax>selected switch labels</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0158" Identifier="SplitVariableDeclaration" Title="Split variable declaration">
    <Syntaxes>
      <Syntax>local declaration</Syntax>
      <Syntax>field declaration</Syntax>
      <Syntax>event field declaration</Syntax>
    </Syntaxes>
    <Images>
      <Image>SplitLocalDeclaration</Image>
    </Images>
  </Refactoring>
  <Refactoring Id="RR0159" Identifier="SwapBinaryOperands" Title="Swap binary operands">
    <Syntaxes>
      <Syntax>binary expression</Syntax>
    </Syntaxes>
    <Span>binary operator</Span>
    <Samples>
      <Sample>
        <Before>
          <![CDATA[if (x && y)
{
{]]>
        </Before>
        <After>
          <![CDATA[if (y && x)
{
{]]>
        </After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0160" Identifier="InvertConditionalExpression" Title="Invert conditional expression">
    <Syntaxes>
      <Syntax>conditional expression</Syntax>
    </Syntaxes>
    <Span>condition</Span>
  </Refactoring>
  <Refactoring Id="RR0161" Identifier="SwapMemberDeclarations" Title="Swap member declarations">
    <Syntaxes>
      <Syntax>empty line between member declarations</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0162" Identifier="InvertIfElse" Title="Invert if-else">
    <Syntaxes>
      <Syntax>if-else statement</Syntax>
    </Syntaxes>
    <Span>if keyword</Span>
  </Refactoring>
  <Refactoring Id="RR0163" Identifier="UncommentSingleLineComment" Title="Uncomment single-line comment">
    <Syntaxes>
      <Syntax>single-line comment(s)</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0164" Identifier="ConvertHasFlagCallToBitwiseOperation" Title="Convert 'HasFlag' call to bitwise operation">
    <Syntaxes>
      <Syntax>Enum.HasFlag method invocation</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0165" Identifier="UseCoalesceExpressionInsteadOfIf" Title="Use coalesce expression instead of if">
    <Syntaxes>
      <Syntax>if statement</Syntax>
    </Syntaxes>
    <Span>top if keyword or selected if statement</Span>
  </Refactoring>
  <Refactoring Id="RR0166" Identifier="ConvertIfToConditionalOperator" Title="Convert 'if' to ?:">
    <Syntaxes>
      <Syntax>if statement</Syntax>
    </Syntaxes>
    <Span>top if keyword or selected if statement</Span>
  </Refactoring>
  <Refactoring Id="RR0167" Identifier="UseElementAccessInsteadOfEnumerableMethod" Title="Use element access instead of 'First/Last'ElementAt' method">
    <Syntaxes>
      <Syntax>First/Last/ElementAt method invocation</Syntax>
    </Syntaxes>
    <Span>method name</Span>
  </Refactoring>
  <Refactoring Id="RR0168" Identifier="UseEmptyStringLiteralInsteadOfStringEmpty" Title="Use &quot;&quot; instead of string.Empty" IsObsolete="true">
    <Syntaxes>
      <Syntax>string.Empty field</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0169" Identifier="ConvertBlockBodyToExpressionBody" Title="Convert block body to expression-body">
    <Syntaxes>
      <Syntax>method</Syntax>
      <Syntax>property</Syntax>
      <Syntax>indexer</Syntax>
      <Syntax>operator</Syntax>
    </Syntaxes>
    <Span>body or accessor list</Span>
  </Refactoring>
  <Refactoring Id="RR0170" Identifier="UseLambdaExpressionInsteadOfAnonymousMethod" Title="Use lambda expression instead of anonymous method">
    <Syntaxes>
      <Syntax>anonymous method</Syntax>
    </Syntaxes>
    <Span>delegate keyword</Span>
  </Refactoring>
  <Refactoring Id="RR0171" Identifier="ConvertEmptyStringToStringEmpty" Title="Convert &quot;&quot; to string.Empty" IsEnabledByDefault="false">
    <Syntaxes>
      <Syntax>empty string literal</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0172" Identifier="WrapInCondition" Title="Wrap in condition">
    <Syntaxes>
      <Syntax>selected statements</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0173" Identifier="WrapInElseClause" Title="Wrap in else clause" IsObsolete="true">
    <Syntaxes>
      <Syntax>statement</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0174" Identifier="WrapInIfDirective" Title="Wrap in #if directive">
    <Syntaxes>
      <Syntax>selected lines</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0175" Identifier="WrapInRegion" Title="Wrap in region">
    <Syntaxes>
      <Syntax>selected lines</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0176" Identifier="WrapInTryCatch" Title="Wrap in try-catch">
    <Syntaxes>
      <Syntax>selected statements</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0177" Identifier="WrapInUsingStatement" Title="Wrap in using statement">
    <Syntaxes>
      <Syntax>local declaration of type that implements IDisposable</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0178" Identifier="AddTypeParameter" Title="Add type parameter">
    <Syntaxes>
      <Syntax>class declaration</Syntax>
      <Syntax>struct declaration</Syntax>
      <Syntax>interface declaration</Syntax>
      <Syntax>delegate declaration</Syntax>
      <Syntax>method declaration</Syntax>
      <Syntax>local function</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0179" Identifier="ImplementIEquatableOfT" Title="Implement IEquatable&lt;T&gt;">
    <Syntaxes>
      <Syntax>class declaration</Syntax>
      <Syntax>struct declaration</Syntax>
      <Syntax>interface declaration</Syntax>
    </Syntaxes>
    <Span>base list</Span>
  </Refactoring>
  <Refactoring Id="RR0180" Identifier="InlineUsingStatic" Title="Inline using static">
    <Syntaxes>
      <Syntax>using static directive</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0181" Identifier="InlineConstant" Title="Inline constant">
    <Syntaxes>
      <Syntax>constant declaration</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0182" Identifier="UseStringBuilderInsteadOfConcatenation" Title="Use StringBuilder instead of concatenation">
    <Syntaxes>
      <Syntax>string concatenation</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0183" Identifier="UseListInsteadOfYield" Title="Use List&lt;T&gt; instead of yield">
    <Syntaxes>
      <Syntax>yield return</Syntax>
      <Syntax>yield break</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0184" Identifier="SplitIfStatement" Title="Split if statement">
    <Syntaxes>
      <Syntax>if statement that has logical or expression as a condition</Syntax>
    </Syntaxes>
    <Span>top if keyword or selected if statement</Span>
  </Refactoring>
  <Refactoring Id="RR0185" Identifier="ReplaceObjectCreationWithDefaultValue" Title="Replace object creation with default value">
    <Syntaxes>
      <Syntax>object creation expression</Syntax>
    </Syntaxes>
    <Samples>
      <Sample>
        <Before><![CDATA[var x = new object();]]></Before>
        <After><![CDATA[object x = null;]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[var arr = new object[0];]]></Before>
        <After><![CDATA[object[] arr = null;]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0186" Identifier="ChangeAccessibility" Title="Change accessibility">
    <Syntaxes>
      <Syntax>access modifier</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0187" Identifier="WrapConstraintClauses" Title="Wrap constraint clauses">
    <Syntaxes>
      <Syntax>type parameter constraint clause</Syntax>
    </Syntaxes>
    <Samples>
      <Sample>
        <Before><![CDATA[private void Foo<T1, T2, T3>() where T1 : class where T2 : class where T3 : class
{
}]]></Before>
        <After><![CDATA[private void Foo<T1, T2, T3>()
    where T1 : class
    where T2 : class
    where T3 : class
{
}]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0188" Identifier="ConvertForEachToForAndReverseLoop" Title="Convert 'foreach' to 'for' and reverse loop" IsEnabledByDefault="false">
    <Syntaxes>
      <Syntax>foreach statement</Syntax>
    </Syntaxes>
    <Samples>
      <Sample>
        <Before><![CDATA[foreach (object item in items)
{
    yield return item;
}]]></Before>
        <After><![CDATA[for (int i = items.Count - 1; i >= 0; i--)
{
    yield return items[i];
}]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0189" Identifier="InvertIf" Title="Invert if">
    <Syntaxes>
      <Syntax>if statement</Syntax>
    </Syntaxes>
    <Span>if keyword</Span>
    <Samples>
      <Sample>
        <Before><![CDATA[if (condition1)
{
    if (condition2)
    {
        Foo();
    }
}]]></Before>
        <After><![CDATA[if (!condition1)
{
    return;
}

if (!condition2)
{
    return;
}

Foo();]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[if (!condition1)
{
    return;
}

if (!condition2)
{
    return;
}

Foo();]]></Before>
        <After><![CDATA[if (condition1)
{
    if (condition2)
    {
        Foo();
    }
}]]></After>
      </Sample>
  </Samples>
  </Refactoring>
  <Refactoring Id="RR0190" Identifier="SplitIfElse" Title="Split if-else">
    <Syntaxes>
      <Syntax>if statement</Syntax>
    </Syntaxes>
    <Span>selected if statement or topmost if keyword</Span>
    <Samples>
      <Sample><Before><![CDATA[if (condition1)
{
    return Foo1();
{
else if (condition2)
{
    return Foo2();
}
else
{
    return false;
}]]></Before><After><![CDATA[if (condition1)
{
    return Foo1();
{

if (condition2)
{
    return Foo2();
}

return false;]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0191" Identifier="UseCSharp6DictionaryInitializer" Title="Use C# 6.0 dictionary initializer">
    <Syntaxes>
      <Syntax>collection initializer</Syntax>
    </Syntaxes>
    <Samples>
      <Sample>
        <Before><![CDATA[var dic = new Dictionary<int, string>() { { 0, "0" } };]]></Before>
        <After><![CDATA[var dic = new Dictionary<int, string>() { [0] = "0" };]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0192" Identifier="ConvertCommentToDocumentationComment" Title="Convert comment to documentation comment">
    <Syntaxes>
      <Syntax>single-line comment</Syntax>
    </Syntaxes>
    <Samples>
      <Sample>
        <Before><![CDATA[// comment
public class Foo
{
}]]></Before>
        <After><![CDATA[/// <summary>
/// comment
/// </summary>
public class Foo
{
}]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0193" Identifier="ConvertInterpolatedStringToConcatenation" Title="Convert interpolated string to concatenation">
    <Syntaxes>
      <Syntax>interpolated string</Syntax>
    </Syntaxes>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = $"a{b}c";]]></Before>
        <After><![CDATA[string s = "a" + b + "c";]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0194" Identifier="SplitDeclarationAndInitialization" Title="Split declaration and initialization">
    <Syntaxes>
      <Syntax>local variable declaration</Syntax>
    </Syntaxes>
    <Span>equals token</Span>
    <Samples>
      <Sample>
        <Before><![CDATA[var s = GetValue();]]></Before>
        <After><![CDATA[string s;
s = GetValue();]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0195" Identifier="AddMemberToInterface" Title="Add member to interface">
    <Syntaxes>
      <Syntax>method</Syntax>
      <Syntax>property</Syntax>
      <Syntax>indexer</Syntax>
      <Syntax>event</Syntax>
    </Syntaxes>
    <Span>identifier</Span>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo : IFoo
{
    public void Bar()
    {
    }
}

public interface IFoo
{
}]]></Before>
        <After><![CDATA[public class Foo : IFoo
{
    public void Bar()
    {
    }
}

public interface IFoo
{
    void Bar();
}]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0196" Identifier="MergeIfWithParentIf" Title="Merge if with parent if">
    <Syntaxes>
      <Syntax>if statement</Syntax>
    </Syntaxes>
    <Span>if keyword</Span>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x)
{
    if (y)
    {
    }
}
else
{
}]]></Before>
        <After><![CDATA[if (x && y)
{
}
else
{
}]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0197" Identifier="InitializeFieldFromConstructor" Title="Initialize field from constructor">
    <Syntaxes>
      <Syntax>field declaration</Syntax>
    </Syntaxes>
    <Span>idenifier</Span>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{
    private string _bar;

    public Foo()
    {
    }

    public Foo(object parameter)
    {
    }

    public Foo(object parameter1, object parameter2)
        : this(parameter1)
    {
    }
}]]></Before>
        <After><![CDATA[public class Foo
{
    private string _bar;

    public Foo(string bar)
    {
        _bar = bar;
    }

    public Foo(object parameter, string bar)
    {
        _bar = bar;
    }

    public Foo(object parameter1, object parameter2, string bar)
        : this(parameter1, bar)
    {
        _bar = bar;
    }
}]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0198" Identifier="InlineProperty" Title="Inline property">
    <Syntaxes>
      <Syntax>property access</Syntax>
    </Syntaxes>
  </Refactoring>
  <Refactoring Id="RR0199" Identifier="RemoveEnumMemberValue" Title="Remove enum member value(s)">
    <Syntaxes>
      <Syntax>selected enum member(s)</Syntax>
    </Syntaxes>
    <Samples>
      <Sample>
        <Before><![CDATA[public enum Foo
{
    One = 1,
    Two = 2,
    Three = 3
}]]></Before>
        <After><![CDATA[public enum Foo
{
    One,
    Two,
    Three
}]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0200" Identifier="UncommentMultiLineComment" Title="Uncomment multi-line comment">
    <Syntaxes>
      <Syntax>multi-line comment</Syntax>
    </Syntaxes>
    <Samples>
      <Sample>
        <Before><![CDATA[/*string s = null;*/]]></Before>
        <After><![CDATA[string s = null;]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0201" Identifier="ConvertInterpolatedStringToStringFormat" Title="Convert interpolated string to 'string.Format'">
    <Syntaxes>
      <Syntax>interpolated string</Syntax>
    </Syntaxes>
    <Samples>
      <Sample>
        <Before><![CDATA[$"name: {name,0:f}, value: {value}"]]></Before>
        <After><![CDATA[string.Format("name: {0,0:f} value: {1}", name, value)]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0202" Identifier="MoveUnsafeContextToContainingDeclaration" Title="Move unsafe context to containing declaration">
    <Syntaxes>
      <Syntax>unsafe declaration</Syntax>
    </Syntaxes>
    <Span>unsafe modifier</Span>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{
  public unsafe void Bar()
  {
  }
}]]></Before>
        <After><![CDATA[public unsafe class Foo
{
  public void Bar()
  {
  }
}]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0203" Identifier="ExtractEventHandlerMethod" Title="Extract event handler method">
    <Syntaxes>
      <Syntax>lambda expression</Syntax>
    </Syntaxes>
    <Samples>
      <Sample>
        <Before><![CDATA[void Foo()
{
  x.Changed += (s, e) => Bar();
}]]></Before>
        <After><![CDATA[void Foo()
{
  x.Changed += Changed;
}

void OnChanged(object sender, EventArgs e)
{
  Bar();
}]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0204" Identifier="GeneratePropertyForDebuggerDisplayAttribute" Title="Generate property for DebuggerDisplay attribute">
    <Syntaxes>
      <Syntax>DebuggerDisplay attribute</Syntax>
    </Syntaxes>
    <Links>
      <Link>
        <Url>https://docs.microsoft.com/en-us/visualstudio/debugger/using-the-debuggerdisplay-attribute#using-expressions-in-debuggerdisplay</Url>
        <Text>Using Expressions in DebuggerDisplay</Text>
      </Link>
      <Link>
        <Url>https://blogs.msdn.microsoft.com/jaredpar/2011/03/18/debuggerdisplay-attribute-best-practices/</Url>
        <Text>DebuggerDisplay attribute best practices</Text>
      </Link>
    </Links>
    <Samples>
      <Sample>
        <Before><![CDATA[[DebuggerDisplay("A: {A} B: {B}")]
public class Foo
{
    public string A { get; }
    public string B { get; }
}]]></Before>
        <After><![CDATA[DebuggerDisplay("{DebuggerDisplay,nq}")]
public class Foo
{
    public string A { get; }
    public string B { get; }

    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private string DebuggerDisplay
    {
        get { return $"A: {A} B: {B}"; }
    }
}]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0205" Identifier="AddEmptyLineBetweenDeclarations" Title="Add empty line between declarations">
    <Syntaxes>
      <Syntax>selected declarations</Syntax>
    </Syntaxes>
    <Samples>
      <Sample>
        <Before><![CDATA[private object x;
private object y;
private object z;]]></Before>
        <After><![CDATA[private object x;

private object y;

private object z;]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0206" Identifier="UseEnumeratorExplicitly" Title="Use enumerator explicitly">
    <Syntaxes>
      <Syntax>foreach statement</Syntax>
    </Syntaxes>
    <Span>foreach keyword</Span>
    <Samples>
      <Sample>
        <Before>
          <![CDATA[foreach (var item in items)
{
    yield return item;
}]]>
        </Before>
        <After>
          <![CDATA[using (var en = items.GetEnumerator())
{
    while (en.MoveNext())
    {
        yield return item;
    }
}]]>
        </After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0207" Identifier="SortCaseLabels" Title="Sort case labels">
    <Syntaxes>
      <Syntax>selected case labels with string literal or enum field</Syntax>
    </Syntaxes>
    <Span></Span>
    <Samples>
      <Sample>
        <Before><![CDATA[bool Foo(string s)
{
    switch (s)
    {
        case "d":
        case "b":
        case "a":
        case "c":
            return true;
        default:
            return false;
    }
}]]></Before>
        <After><![CDATA[bool Foo(string s)
{
    switch (s)
    {
        case "a":
        case "b":
        case "c":
        case "d":
            return true;
        default:
            return false;
    }
}]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0208" Identifier="AddTagToDocumentationComment" Title="Add tag to documentation comment">
    <Syntaxes>
      <Syntax>selected word(s) in documentation comment</Syntax>
    </Syntaxes>
    <Samples>
      <Sample>
        <Before><![CDATA[/// <summary>
/// null
/// </summary>
public class Foo
{
}
]]></Before>
        <After><![CDATA[/// <summary>
/// <c>null</c>
/// </summary>
public class Foo
{
}]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0209" Identifier="RemoveAsyncAwait" Title="Remove async/await">
    <Syntaxes>
      <Syntax>method declaration</Syntax>
      <Syntax>local function</Syntax>
      <Syntax>lambda</Syntax>
      <Syntax>anonymous method</Syntax>
    </Syntaxes>
    <Span>async keyword</Span>
    <Samples>
      <Sample>
        <Before><![CDATA[class C
{
    async Task<object> FooAsync()
    {
        return await BarAsync().ConfigureAwait(false);
    }
}]]></Before>
        <After><![CDATA[class C
{
    Task<object> FooAsync()
    {
        return BarAsync();
    }
}]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0210" Identifier="ImplementCustomEnumerator" Title="Implement custom enumerator">
    <Syntaxes>
      <Syntax>class that implements IEnumerable&lt;T&gt;</Syntax>
    </Syntaxes>
    <Span>identifier</Span>
    <Samples>
      <Sample>
        <Before><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;

class C<T> : IEnumerable<T>
{
    IEnumerator<T> IEnumerable<T>.GetEnumerator()
    {
        throw new NotImplementedException();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        throw new NotImplementedException();
    }
}]]></Before>
        <After><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;

class C<T> : IEnumerable<T>
{
    IEnumerator<T> IEnumerable<T>.GetEnumerator()
    {
        throw new NotImplementedException();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        throw new NotImplementedException();
    }

    public Enumerator GetEnumerator()
    {
        return new Enumerator(this);
    }

    public struct Enumerator
    {
        private readonly C<T> _c;
        private int _index;

        internal Enumerator(C<T> c)
        {
            _c = c;
            _index = -1;
        }

        public T Current
        {
            get
            {
                throw new NotImplementedException();
            }
        }

        public bool MoveNext()
        {
            throw new NotImplementedException();
        }

        public void Reset()
        {
            _index = -1;
            throw new NotImplementedException();
        }

        public override bool Equals(object obj)
        {
            throw new NotSupportedException();
        }

        public override int GetHashCode()
        {
            throw new NotSupportedException();
        }
    }

    //TODO: IEnumerable.GetEnumerator() and IEnumerable<T>.GetEnumerator() should return instance of EnumeratorImpl.
    private class EnumeratorImpl : IEnumerator<T>
    {
        private Enumerator _e;

        internal EnumeratorImpl(C<T> c)
        {
            _e = new Enumerator(c);
        }

        public T Current
        {
            get
            {
                return _e.Current;
            }
        }

        object IEnumerator.Current
        {
            get
            {
                return _e.Current;
            }
        }

        public bool MoveNext()
        {
            return _e.MoveNext();
        }

        void IEnumerator.Reset()
        {
            _e.Reset();
        }

        void IDisposable.Dispose()
        {
        }
    }
}]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0211" Identifier="ConvertStatementsToIfElse" Title="Convert statements to if-else">
    <Syntaxes>
      <Syntax>selected statements (first statement must be 'if' statement)</Syntax>
    </Syntaxes>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x)
    return 1;

if (y)
{
    return 2;
}
else if (z)
{
    return 3;
}

return 0;]]></Before>
        <After><![CDATA[if (x)
{
    return 1;
}
else if (y)
{
    return 2;
}
else if (z)
{
    return 3;
}
else
{
    return 0;
}]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0212" Identifier="DuplicateSwitchSection" Title="Duplicate switch section">
    <Syntaxes>
      <Syntax>switch section</Syntax>
    </Syntaxes>
    <Span>close brace or empty line after switch section</Span>
    <Samples>
      <Sample>
        <Before>
          <![CDATA[switch (s)
{
    case "a":
        {
            // ...

            break;
        }
    default:
        {
            break;
        }
}]]>
        </Before>
        <After>
          <![CDATA[switch (s)
{
    case "a":
        {
            // ...

            break;
        }
    case "a":
        {
            // ...

            break;
        }
    default:
        {
            break;
        }
}]]>
        </After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0213" Identifier="AddParameterToInterfaceMember" Title="Add parameter to interface member">
    <Syntaxes>
      <Syntax>method declaration</Syntax>
      <Syntax>indexer declaration</Syntax>
    </Syntaxes>
    <Span>method name or 'this' keyword</Span>
    <Samples>
      <Sample>
        <Before><![CDATA[interface IFoo
{
    void Bar(object p);
}

class Foo : IFoo
{
    public void Bar(object p, object p2)
    {
    }
}]]></Before>
        <After><![CDATA[interface IFoo
{
    void Bar(object p, object p2);
}

class Foo : IFoo
{
    public void Bar(object p, object p2)
    {
    }
}]]></After>
      </Sample>
    </Samples>
  </Refactoring>
  <Refactoring Id="RR0214" Identifier="ConvertSwitchExpressionToSwitchStatement" Title="Convert 'switch' expression to 'switch' statement">
    <Syntaxes>
      <Syntax>switch expression</Syntax>
    </Syntaxes>
    <Span>switch keyword</Span>
    <Samples>
      <Sample>
        <Before><![CDATA[return dayOfWeek switch
{
    DayOfWeek.Monday => 1,
    DayOfWeek.Tuesday => 2,
    DayOfWeek.Wednesday => 3,
    DayOfWeek.Thursday => 4,
    DayOfWeek.Friday => 5,
    _ => throw new Exception(),
};
]]></Before>
        <After><![CDATA[switch (dayOfWeek)
{
    case DayOfWeek.Monday:
        return 1;
    case DayOfWeek.Tuesday:
        return 2;
    case DayOfWeek.Wednesday:
        return 3;
    case DayOfWeek.Thursday:
        return 4;
    case DayOfWeek.Friday:
        return 5;
    default:
        throw new Exception();
}
]]></After>
      </Sample>
    </Samples>
  </Refactoring>
</Refactorings>